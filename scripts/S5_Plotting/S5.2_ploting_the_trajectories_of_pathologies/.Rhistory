# Creating data for decedents
cluster1_decedents =  total_trend_plot_decedents %>% subset(cluster==1)
cluster2_decedents =  total_trend_plot_decedents %>% subset(cluster==2)
cluster3_decedents =  total_trend_plot_decedents %>% subset(cluster==3)
# Creating data for living
cluster1_living =  total_trend_plot_living %>% subset(cluster==1)
cluster2_living =  total_trend_plot_living %>% subset(cluster==2)
cluster3_living =  total_trend_plot_living %>% subset(cluster==3)
total_trend_plot_decedents %>%
distinct(projid, cluster) %>%
count(cluster, name = "n_projid")
total_trend_plot_living %>%
distinct(projid, cluster) %>%
count(cluster, name = "n_projid")
# For satisfying the condition for ploting - decedents with at least 2 visits before onset & x axis from -5 to 3.
# In the cut version, keep only these projid values and set the timeline range from -5 to 3
cluster_cuts_decedents <- list()
for (k in 1:3) {
# Dynamically generate names: "cluster1_cut", "cluster2_cut", "cluster3_cut"
nm <- paste0("cluster", k, "_cut_decedents")
# Filter by cluster = k, good_ids_decedents, and timeline range
cluster_cuts_decedents[[nm]] <- total_trend_plot_decedents %>%
filter(
cluster %in% k,
# projid %in% good_ids_decedents,
timeline >= -5,
timeline <= 3
)
}
list2env(cluster_cuts_decedents, envir = .GlobalEnv)
# 1) Count the number of unique projid values in each subset
projid_counts <- map_int(cluster_cuts_decedents, ~ n_distinct(.x$projid))
# 2) Convert to a data frame
result <- tibble(
cluster        = names(projid_counts),
unique_projids = projid_counts
)
print(result)
# table(PC_label$AD_label,PC_label$NIA)
table(total_trend_plot_decedents$ADD,total_trend_plot_decedents$cluster)
# For living
# In the cut version, only keep these projid values and set the timeline range to -5…3
cluster_cuts_living <- list()
for (k in 1:3) {
# Dynamically generate names: "cluster1_cut", "cluster2_cut", "cluster3_cut"
nm <- paste0("cluster", k, "_cut_living")
# Filter by cluster = k, good_ids_living, and timeline range
cluster_cuts_living[[nm]] <- total_trend_plot_living %>%
filter(
cluster %in% k,
# projid %in% good_ids_living,
timeline >= -5,
timeline <= 3
)
}
list2env(cluster_cuts_living, envir = .GlobalEnv)
# 1) Count the number of unique projid values in each subset
projid_counts <- map_int(cluster_cuts_living, ~ n_distinct(.x$projid))
# 2) Convert to a data frame
result <- tibble(
cluster        = names(projid_counts),
unique_projids = projid_counts
)
print(result)
# table(PC_label$AD_label,PC_label$NIA)
table(total_trend_plot_living$ADD,total_trend_plot_living$cluster)
# Print it out the rotation
cont = PCA$rotation %>% as.table() %>% as.data.frame()%>%filter(Var2%in%c("PC1","PC2"))
# print(cont)
colnames(cont) = c("feature","PC","coefficient")
# print(cont)
cont = cont %>% arrange(coefficient)
PC1 = cont %>% subset(PC=="PC1") %>% mutate(neg = coefficient<0)
PC2 = cont %>% subset(PC=="PC2") %>% mutate(neg = coefficient<0)
ggplot(PC1,aes(x = reorder(feature,coefficient), y = coefficient, fill = neg)) + geom_col() + coord_flip() + labs(x="feature") +
theme(legend.position = "none")
ggplot(PC2,aes(x = reorder(feature,coefficient), y = coefficient, fill = neg)) + geom_col() + coord_flip() + labs(x="feature") +
theme(legend.position = "none")
clusters_list_decedents <- list(
cluster1_decedents     = cluster1_decedents,
cluster2_decedents     = cluster2_decedents,
cluster3_decedents     = cluster3_decedents,
cluster1_cut_decedents = cluster1_cut_decedents,
cluster2_cut_decedents = cluster2_cut_decedents,
cluster3_cut_decedents = cluster3_cut_decedents
)
clusters_list_decedents_complete <- list(
cluster1_decedents     = cluster1_decedents,
cluster2_decedents     = cluster2_decedents,
cluster3_decedents     = cluster3_decedents
)
clusters_list_decedents_cut <- list(
cluster1_cut_decedents = cluster1_cut_decedents,
cluster2_cut_decedents = cluster2_cut_decedents,
cluster3_cut_decedents = cluster3_cut_decedents
)
# For living
clusters_list_living <- list(
cluster1_living     = cluster1_living,
cluster2_living     = cluster2_living,
cluster3_living     = cluster3_living,
cluster1_cut_living = cluster1_cut_living,
cluster2_cut_living = cluster2_cut_living,
cluster3_cut_living = cluster3_cut_living
)
clusters_list_living_complete <- list(
cluster1_living     = cluster1_living,
cluster2_living     = cluster2_living,
cluster3_living     = cluster3_living
)
clusters_list_living_cut <- list(
cluster1_cut_living = cluster1_cut_living,
cluster2_cut_living = cluster2_cut_living,
cluster3_cut_living = cluster3_cut_living
)
vars <- c("pred_amyloid", "pred_tangles", "pred_gpath", "pred_NIA")
# --- Extract and export the unique projid values for each cluster in decedents ---
# Ensure the output directory exists
out_dir <- "outputs/S6/Decedents_cluster_projids_1106"
if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
# Specify the three clusters to process
cluster_names <- c("cluster1_decedents", "cluster2_decedents", "cluster3_decedents")
for (cl in cluster_names) {
# Retrieve the corresponding data.frame from the list
df_cl <- clusters_list_decedents[[cl]]
# Calculate the number of rows and unique projid values
n_rows       <- nrow(df_cl)
unique_ids   <- unique(df_cl$projid)
n_unique_ids <- length(unique_ids)
# Print information
message(sprintf(">> predicted pathologies in %s | n rows: %d | unique projid: %d",
cl, n_rows, n_unique_ids))
# Export the projid list to a CSV file
write.csv(
data.frame(projid = unique_ids),
file      = file.path(out_dir, paste0(cl, "_projids.csv")),
row.names = FALSE,
quote     = FALSE
)
}
# --- Extract and export the unique projid values for each cluster in decedents ---
# Ensure the output directory exists
out_dir <- "outputs/S6/Livings_cluster_projids_1106"
if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
# Specify the three clusters to process
cluster_names <- c("cluster1_living", "cluster2_living", "cluster3_living")
for (cl in cluster_names) {
# Retrieve the corresponding data.frame from the list
df_cl <- clusters_list_living[[cl]]
# Calculate the number of rows and unique projid values
n_rows       <- nrow(df_cl)
unique_ids   <- unique(df_cl$projid)
n_unique_ids <- length(unique_ids)
# Print information
message(sprintf(">> predicted pathologies in %s | n rows: %d | unique projid: %d",
cl, n_rows, n_unique_ids))
# Export the projid list to a CSV file
write.csv(
data.frame(projid = unique_ids),
file      = file.path(out_dir, paste0(cl, "_projids.csv")),
row.names = FALSE,
quote     = FALSE
)
}
clusters_list_decedents_AP <- clusters_list_decedents
clusters_list_living_AP <- clusters_list_living
save(
clusters_list_decedents_AP,
file = "outputs/S6/clusters_list_decedents_FromAllP.RData"
)
save(
clusters_list_living_AP,
file = "outputs/S6/clusters_list_living_FromAllP.RData"
)
# 1) Calculate the global [min, max] for each variable for the complete version of clusters
global_limits_complete_decedents <- map(vars, function(varname) {
# 1) Use map() to collect the min/max of each cluster (a list, each element of length 2)
per_cluster <- map(clusters_list_decedents_complete, ~ range(.x[[varname]], na.rm = TRUE))
# 2) Flatten into a pure numeric vector (length = number of clusters × 2)
all_vals   <- flatten_dbl(per_cluster)
# 3) Take the global min/max
c(min(all_vals), max(all_vals))
})
names(global_limits_complete_decedents) <- vars
# Version 2
global_limits_cut_decedents <- map(vars, function(varname) {
# Keep only non-empty data.frames where the column has at least one non-NA value
valid_ranges <- clusters_list_decedents_cut %>%
keep(~ nrow(.x) > 0 && any(!is.na(.x[[varname]]))) %>%
map(~ range(.x[[varname]], na.rm = TRUE))
# Flatten into a pure numeric vector (only keep finite values), then calculate the global min/max
all_vals <- flatten_dbl(valid_ranges)
all_vals <- all_vals[is.finite(all_vals)]
c(min(all_vals), max(all_vals))
})
names(global_limits_cut_decedents) <- vars
# 1) Calculate the global [min, max] for each variable for the complete version of clusters
global_limits_complete_living <- map(vars, function(varname) {
# 1) Use map() to collect the min/max of each cluster (a list, each element length 2)
per_cluster <- map(clusters_list_living_complete, ~ range(.x[[varname]], na.rm = TRUE))
# 2) Flatten into a pure numeric vector (length = number of clusters × 2)
all_vals   <- flatten_dbl(per_cluster)
# 3) Take the global min/max
c(min(all_vals), max(all_vals))
})
names(global_limits_complete_living) <- vars
# 1) Calculate the global [min, max] for each variable for the cut version of clusters
global_limits_cut_living <- map(vars, function(varname) {
# 1) Use map() to collect the min/max of each cluster (a list, each element length 2)
per_cluster <- map(clusters_list_living_cut, ~ range(.x[[varname]], na.rm = TRUE))
# 2) Flatten into a pure numeric vector (length = number of clusters × 2)
all_vals   <- flatten_dbl(per_cluster)
# 3) Take the global min/max
c(min(all_vals), max(all_vals))
})
names(global_limits_cut_living) <- vars
# Check the results
global_limits_complete_decedents
global_limits_cut_decedents
global_limits_complete_living
global_limits_cut_living
my_mcinci_fixed_y <- function(df, file, cluster_label, varname,
global_limits_complete, global_limits_cut,
dx = c("ADD","MCI","NCI")) {
dx <- match.arg(dx)  # 只允许 ADD / MCI / NCI
if (!dir.exists(file)) dir.create(file, recursive = TRUE)
## -------- Truncation Rules (keep your original three sections） --------
custom_ranges_ADD <- list(
cluster2_living = c(-15, 6),
cluster1_living = c(-15, 7),
cluster3_living = c(-15, NA)
)
if (cluster_label %in% names(custom_ranges_ADD)) {
rr <- custom_ranges_ADD[[cluster_label]]; lb <- rr[1]; ub <- rr[2]
df <- df %>% filter(!(AD_label == "ADD" &
((!is.na(lb) & timeline < lb) | (!is.na(ub) & timeline > ub))))
}
custom_ranges_NCI <- list(
cluster1_living = c(NA, 22)
)
if (cluster_label %in% names(custom_ranges_NCI)) {
rr <- custom_ranges_NCI[[cluster_label]]; lb <- rr[1]; ub <- rr[2]
df <- df %>% filter(!(AD_label == "NCI" &
((!is.na(lb) & timeline < lb) | (!is.na(ub) & timeline > ub))))
}
custom_ranges_MCI <- list(
cluster3_living = c(NA, 5)
)
if (cluster_label %in% names(custom_ranges_MCI)) {
rr <- custom_ranges_MCI[[cluster_label]]; lb <- rr[1]; ub <- rr[2]
df <- df %>% filter(!(AD_label == "MCI" &
((!is.na(lb) & timeline < lb) | (!is.na(ub) & timeline > ub))))
}
## -------- Keep only the target AD_label --------
df <- dplyr::filter(df, AD_label == dx)
if (nrow(df) == 0) {
message("Skip: no rows after filtering for ", dx, " in ", cluster_label)
return(invisible(NULL))
}
## -------- Variable name mapping & y-axis range --------
nice_var_map <- c(
pred_amyloid = "Amyloid-β",
pred_tangles = "Tangles",
pred_gpath   = "Global AD Pathology",
pred_NIA     = "Pathologic AD"
)
nice_var <- nice_var_map[[varname]]
limits_list <- if (stringr::str_detect(cluster_label, "cut")) global_limits_cut else global_limits_complete
rng  <- limits_list[[varname]]
unit <- if (stringr::str_detect(cluster_label, "cut")) 1 else 5
## -------- Plot (facet still uses ~AD_label, but there will be only one panel） --------
p <- ggplot(df, aes(x = timeline, y = .data[[varname]],
group = projid, color = condition)) +
geom_point() +
geom_line(size = 1) +
stat_summary(aes(group = ADD), fun = mean, geom = "line", colour = "black") +
facet_wrap(~ AD_label, ncol = 1, scales = "free_x") +
scale_color_manual(name = "Condition",
values = c(
"Before Onset" = "#00BFC4",
"After Onset"  = "#F8766D",
"MCI"          = "#00BA38",
"NCI"          = "#C77CFF"
),
drop = FALSE
) +
scale_x_continuous(breaks = scales::breaks_width(unit), expand = c(0,0)) +
scale_y_continuous(limits = rng, expand = c(0,0)) +
# labs(title = paste0(dx, " — ", varname, " in ", cluster_label),
#      x = "Time", y = paste("Imputed", nice_var)) +
theme(
text            = element_text(face = "bold"),
plot.title      = element_text(size = 18),
axis.title      = element_text(face = "bold"),
axis.text       = element_text(face = "bold"),
legend.position = "none",
strip.text      = element_text(size = 14, face = "bold"),
axis.title.x    = element_blank(),
axis.title.y    = element_blank()
)
## -------- Save: only 1 panel each time --------
total_width  <- 3
total_height <- 4
ggsave(
filename = file.path(file, paste0(varname, "_", cluster_label, "_", dx, ".jpg")),
plot     = p,
width    = total_width,
height   = total_height,
dpi      = 300
)
}
# For decedents
for (varname in vars) {
for (nm in names(clusters_list_decedents)) {
df <- clusters_list_decedents[[nm]]
if (nrow(df)==0) next
out_dir <- file.path("outputs/S6/ClusteringPlots", "Decedents", nm)
for (dx in c("ADD","MCI","NCI")) {
my_mcinci_fixed_y(df,
file          = out_dir,
cluster_label = nm,
varname       = varname,
global_limits_complete = global_limits_complete_decedents,
global_limits_cut      = global_limits_cut_decedents,
dx = dx)
}
}
}
# For living
for (varname in vars) {
for (nm in names(clusters_list_living)) {
df <- clusters_list_living[[nm]]
if (nrow(df)==0) next
out_dir <- file.path("outputs/S6/ClusteringPlots", "Living", nm)
for (dx in c("ADD","MCI","NCI")) {
my_mcinci_fixed_y(df,
file          = out_dir,
cluster_label = nm,
varname       = varname,
global_limits_complete = global_limits_complete_living,
global_limits_cut      = global_limits_cut_living,
dx = dx)
}
}
}
count_unique_projids_by_ADD <- function(cluster_list) {
imap_dfr(cluster_list, ~ {
.x %>%
group_by(condition) %>%
summarise(
unique_projids = n_distinct(projid),
.groups = "drop"
) %>%
mutate(cluster = .y, .before = condition)
})
}
# Applying the function.
count_unique_projids_by_ADD(clusters_list_living)
count_unique_projids_by_ADD(clusters_list_decedents)
# ===== Configuration: Variable suffixes for the four pathologies =====
vars <- c("amyloid", "tangles", "gpath", "NIA")
# ===== Cluster order (Decedents / Living; Complete / Cut) =====
cluster_order_complete_dec <- c("cluster2_decedents",      "cluster1_decedents",      "cluster3_decedents")
cluster_order_cut_dec      <- c("cluster2_cut_decedents",  "cluster1_cut_decedents",  "cluster3_cut_decedents")
cluster_order_complete_liv <- c("cluster2_living",         "cluster1_living",         "cluster3_living")
cluster_order_cut_liv      <- c("cluster2_cut_living",     "cluster1_cut_living",     "cluster3_cut_living")
# ===== Utility functions =====
# Construct file names: Prefer <...>_<DX>.jpg; if not found, fall back to the older naming without DX
build_candidate_paths <- function(base_dir, cluster, v, dx) {
fn_with_dx <- file.path(base_dir, cluster, paste0("pred_", v, "_", cluster, "_", dx, ".jpg"))
fn_no_dx   <- file.path(base_dir, cluster, paste0("pred_", v, "_", cluster, ".jpg"))
c(fn_with_dx, fn_no_dx)
}
# Safe image reading: try each candidate path in order, read if exists, otherwise return NULL
safe_image_read <- function(paths) {
for (p in paths) {
if (file.exists(p)) {
im <- tryCatch(image_read(p), error = function(e) NULL)
if (!is.null(im)) return(im)
}
}
NULL
}
# Generic horizontal append with vertical separators.
# If n_expected is given, we pad with blank images to reach that number of columns.
append_with_vlines_generic <- function(imgs, vline, n_expected = NULL) {
imgs_nonnull <- Filter(Negate(is.null), imgs)
if (length(imgs_nonnull) == 0) return(NULL)
if (!is.null(n_expected)) {
ref <- imgs_nonnull[[1]]
blank <- image_blank(width = image_info(ref)$width,
height = image_info(ref)$height,
color  = "white")
if (length(imgs) < n_expected) {
imgs <- c(imgs, rep(list(NULL), n_expected - length(imgs)))
}
imgs <- lapply(imgs, function(im) if (is.null(im)) blank else im)
} else {
imgs <- imgs_nonnull
}
out <- imgs[[1]]
if (length(imgs) >= 2) {
for (k in 2:length(imgs)) out <- image_append(c(out, vline, imgs[[k]]))
}
out
}
# Read one image to determine its size (for creating separator lines);
probe_one_image <- function(base_dir, cluster_order, dx) {
for (cl in cluster_order) {
for (v in vars) {
paths <- build_candidate_paths(base_dir, cl, v, dx)
im <- safe_image_read(paths)
if (!is.null(im)) return(im)
}
}
NULL
}
# Vertically stack multiple rows; insert horizontal lines between rows and align widths
stack_rows_with_hlines <- function(row_imgs) {
row_imgs <- Filter(Negate(is.null), row_imgs)
if (length(row_imgs) == 0) return(NULL)
row_width <- image_info(row_imgs[[1]])$width
hline <- image_blank(width = row_width, height = 2, color = "black")
grid <- row_imgs[[1]]
if (length(row_imgs) >= 2) {
for (r in 2:length(row_imgs)) {
target_w <- max(image_info(grid)$width, image_info(row_imgs[[r]])$width)
grid      <- image_extent(grid,      geometry = paste0(target_w, "x"), gravity = "northwest", color = "white")
row_imgs[[r]] <- image_extent(row_imgs[[r]], geometry = paste0(target_w, "x"), gravity = "northwest", color = "white")
grid <- image_append(c(grid, hline, row_imgs[[r]]), stack = TRUE)
}
}
grid
}
# ===== Main function: Compose a 4×3 grid; swap_rc=TRUE flips rows/cols (Living NCI only per your new spec) =====
compose_dx_grid_generic <- function(
who = c("Decedents","Living"),
version = c("Complete","Cut"),
dx = c("ADD","MCI","NCI"),
strict_three_cols = TRUE,
swap_rc = FALSE,          # NEW: FALSE = 4 rows (pathology) × 3 cols (cluster); TRUE = 3 rows (cluster) × 4 cols (pathology)
base_dir_root = "outputs/S6/ClusteringPlots"  # 新增：图像根目录
) {
who     <- match.arg(who)
version <- match.arg(version)
dx      <- match.arg(dx)
base_dir <- file.path(base_dir_root, who)
if (who == "Decedents" && version == "Complete") cluster_order <- cluster_order_complete_dec
if (who == "Decedents" && version == "Cut")      cluster_order <- cluster_order_cut_dec
if (who == "Living"    && version == "Complete") cluster_order <- cluster_order_complete_liv
if (who == "Living"    && version == "Cut")      cluster_order <- cluster_order_cut_liv
out_dir <- file.path("outputs/S6/ClusteringPlots_2", who, "ByDiagnosis", version)
if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
probe <- probe_one_image(base_dir, cluster_order, dx)
if (is.null(probe)) {
message("No images found for ", who, " - ", version, " - ", dx, ". Skipped.")
return(invisible(NULL))
}
h_single <- image_info(probe)$height
vline    <- image_blank(width = 2, height = h_single, color = "black")
if (!swap_rc) {
# --- 原布局：每一行 = 一个 pathology，行内横排 3 个 cluster ---
n_expected <- if (strict_three_cols) length(cluster_order) else NULL
row_imgs <- lapply(vars, function(v) {
imgs <- lapply(cluster_order, function(cl) {
paths <- build_candidate_paths(base_dir, cl, v, dx)
safe_image_read(paths)
})
append_with_vlines_generic(imgs, vline, n_expected = n_expected)
})
} else {
# --- 对调后布局：每一行 = 一个 cluster，行内横排 4 个 pathology ---
n_expected <- length(vars)  # 固定 4 列
row_imgs <- lapply(cluster_order, function(cl) {
imgs <- lapply(vars, function(v) {
paths <- build_candidate_paths(base_dir, cl, v, dx)
safe_image_read(paths)
})
append_with_vlines_generic(imgs, vline, n_expected = n_expected)
})
}
row_imgs <- Filter(Negate(is.null), row_imgs)
if (length(row_imgs) == 0) {
message("No rows to compose for ", who, " - ", version, " - ", dx, ". Skipped.")
return(invisible(NULL))
}
grid <- stack_rows_with_hlines(row_imgs)
if (is.null(grid)) {
message("Compose failed for ", who, " - ", version, " - ", dx, ". Skipped.")
return(invisible(NULL))
}
out_path <- file.path(out_dir, paste0(dx, "_clusters_4x3.jpg"))
image_write(grid, path = out_path)
message("Saved: ", out_path)
invisible(out_path)
}
# Decedents - Complete
compose_dx_grid_generic("Decedents", "Complete", "ADD", strict_three_cols = FALSE)
compose_dx_grid_generic("Decedents", "Complete", "MCI", strict_three_cols = FALSE)
compose_dx_grid_generic("Decedents", "Complete", "NCI", strict_three_cols = FALSE)
# Decedents - Cut
compose_dx_grid_generic("Decedents", "Cut", "ADD", strict_three_cols = FALSE)
compose_dx_grid_generic("Decedents", "Cut", "MCI", strict_three_cols = FALSE)
compose_dx_grid_generic("Decedents", "Cut", "NCI", strict_three_cols = FALSE)
# Living - Complete
compose_dx_grid_generic("Living", "Complete", "ADD", strict_three_cols = FALSE)
compose_dx_grid_generic("Living", "Complete", "MCI", strict_three_cols = FALSE)
compose_dx_grid_generic("Living", "Complete", "NCI", strict_three_cols = FALSE) #, swap_rc = TRUE)
# Living - Cut
compose_dx_grid_generic("Living", "Cut", "ADD", strict_three_cols = FALSE)
compose_dx_grid_generic("Living", "Cut", "MCI", strict_three_cols = FALSE)
compose_dx_grid_generic("Living", "Cut", "NCI", strict_three_cols = FALSE) #, swap_rc = TRUE)
